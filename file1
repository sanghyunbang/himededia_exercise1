먼저, 현실적인 도서관 관리 시스템을 고려하여 테이블을 보완하고, 전체적인 프로그래밍 계획안을 수립해볼게.
프로젝트의 목표는 콘솔 기반의 도서 대여 관리 프로그램을 만드는 것이고, Java (Eclipse) + MySQL을 사용하여 구현하는 것이므로 이를 중심으로 계획을 정리할게.

📌 1. 프로젝트 개요
📖 프로그램명: 도서 대여 관리 시스템 (Library Rental Management System)
사용 환경: Java (Eclipse) + MySQL
운영 방식: 콘솔 기반
배포 여부: 없음 (개인 사용 목적)
주요 기능:
도서 관리 (등록, 수정, 검색, 삭제)
회원 관리 (등록, 수정, 검색, 삭제)
대출 관리 (대출, 반납, 연장, 연체 확인)
📌 2. 업무 흐름도
업무 흐름을 이해하기 쉽게 아래와 같은 기본적인 흐름도를 작성할 수 있어.

회원 가입 → 도서 등록 → 도서 검색 및 대출 → 반납 또는 연장
연체 상태 관리 및 연체 이력 저장
사서(admin)와 일반 사용자(user) 권한 구분 가능 (추가 가능)
📌 3. 데이터 테이블 설계
기본적으로 도서 관리, 회원 관리, 대출 관리를 위한 테이블을 확장해서 설계해볼게.

📂 3-1. 도서 테이블 (BOOK)
도서 정보를 저장하는 테이블.

컬럼명	타입	설명
ID	INT (PK)	책 ID (자동 증가)
TITLE	VARCHAR(255)	도서 제목
ISBN	VARCHAR(20)	ISBN 번호 (중복 허용 안 함)
AUTHOR	VARCHAR(100)	저자
PUBLISHER	VARCHAR(100)	출판사
ISSUE_YEAR	INT	출판 연도
PRICE	DECIMAL(10,2)	도서 가격
STOCK	INT	총 보유 권수
CREATED	TIMESTAMP	생성일
UPDATED	TIMESTAMP	수정일
📂 3-2. 회원 테이블 (MEMBER)
회원 정보를 저장하는 테이블.

컬럼명	타입	설명
ID	INT (PK)	회원 ID (자동 증가)
NAME	VARCHAR(100)	이름
USERID	VARCHAR(50)	회원 계정 ID
PASSWORD	VARCHAR(255)	비밀번호 (해싱 필요)
GENDER	ENUM('M','F')	성별
MOBILE	VARCHAR(20)	휴대폰 번호
EMAIL	VARCHAR(100)	이메일 주소
REGISTERED	TIMESTAMP	가입일
UPDATED	TIMESTAMP	수정일
📂 3-3. 대출 테이블 (RENT)
도서 대출 정보를 저장하는 테이블.

컬럼명	타입	설명
ID	INT (PK)	대출 ID (자동 증가)
BOOK_ID	INT (FK)	도서 ID (BOOK 테이블 참조)
MEMBER_ID	INT (FK)	회원 ID (MEMBER 테이블 참조)
RENT_DATE	TIMESTAMP	대출일 (CURRENT_TIMESTAMP)
EXPECTED_RETURN	TIMESTAMP	반납 예정일 (대출일 + 14일)
RETURNED_DATE	TIMESTAMP	실제 반납일
EXTENDED_DATE	TIMESTAMP	연장된 날짜 (NULL이면 연장 안 함)
STATUS	ENUM('대출중', '반납됨', '연체')	대출 상태
📂 3-4. 연체 테이블 (OVERDUE)
연체된 내역을 별도로 관리하는 테이블.

컬럼명	타입	설명
ID	INT (PK)	연체 ID (자동 증가)
RENT_ID	INT (FK)	대출 ID (RENT 테이블 참조)
MEMBER_ID	INT (FK)	회원 ID (MEMBER 테이블 참조)
OVERDUE_DAYS	INT	연체 일수
FINE_AMOUNT	DECIMAL(10,2)	연체료 (예: 1일당 500원)
PAID_STATUS	ENUM('미납', '완납')	연체료 납부 상태
📌 4. 요구사항 명세서
✅ 기본 요구사항
📍 도서 관리
 도서 등록 (C)
 도서 정보 조회 (R)
전체 도서 목록 조회
책 제목 또는 저자 이름으로 검색
 도서 정보 수정 (U)
 도서 삭제 (D)
📍 회원 관리
 회원 가입 (C)
 회원 정보 조회 (R)
전체 회원 목록 조회
회원 이름으로 검색
 회원 정보 수정 (U)
 회원 탈퇴 (D)
📍 대출 관리
 도서 대출 (C)
 대출 내역 조회 (R)
대출 중인 도서 목록 조회
반납 완료된 내역 조회
연체 내역 조회
 반납 처리 (U)
 대출 연장 (U)
 연체 시 자동 처리 (U)
📌 5. 개발 계획
단계	세부 항목	설명
1단계	프로젝트 세팅	Java + Eclipse + MySQL 환경 설정
2단계	ERD 설계	MySQL 테이블 및 관계 정의
3단계	CRUD 구현	기본 기능 (도서, 회원, 대출 관리)
4단계	검색 기능	제목, 저자, 회원 검색 추가
5단계	대출/반납	대출, 반납, 연장 기능 구현
6단계	연체 기능	연체 발생 및 연체료 관리 기능
7단계	테스트	데이터 입력 및 검증
8단계	문서화	README.md 작성 및 GitHub 등록
📌 6. 추가 고려사항
로그인/인증 시스템 구현 여부

회원별 계정을 만들어 로그인 후 사용 가능하게 할 것인지?
사서(admin)와 일반 사용자(user) 권한을 구분할 것인지?
대출 가능 권수 제한

한 회원이 동시에 빌릴 수 있는 최대 도서 권수를 설정할지?
연체료 정책

하루 연체 시 500원 같은 벌금 시스템 적용 여부
로그 관리

도서 반납/대출 로그를 저장하여 히스토리를 관리할지?
📌 7. 결론
이 계획을 기반으로 하나씩 구현하면 체계적으로 프로젝트를 진행할 수 있을 거야.
우선 MySQL에 테이블을 정의하고, 기본적인 CRUD 기능부터 구현한 후, 대출 및 연체 기능을 추가하는 방식으로 진행하면 돼.

이제 다음 단계로 ERD 다이어그램과 구체적인 SQL 테이블 스크립트를 작성해볼까? 😊








나의 말:
1. 우선 추가 고려 사항에 대해서 말해줄게.
1) 로그인 / 인증 시스템 구현 여부
: 인증 시스템을 구현하려고 해. 사서는 모든 자료 열람이 가능한 반면, 일반 사용자는 해당 아이디와 패스워드를 입력하고 도서 열람은 모두 가능하지만, 회원 정보는 본인으로 제한되도록 하고 싶어.

2) 대출 가능 권수는 최대 5권으로 하고 싶어.

3) 연체료는 하루 500원으로 하고 싶어/

4) 반납/대출 로그를 저장해서 히스토리를 관리하고 싶어

이를 고려하고 다음 부분을 할 공간이 되면 이어서 해줘
ChatGPT의 말:
메모리 업데이트됨
이제 위의 고려 사항을 반영하여 ERD 다이어그램, 테이블 정의서, 요구사항 명세서, 그리고 전체적인 개발 계획을 구체적으로 작성할게.

📌 1. ERD 다이어그램 (개념적 데이터 모델)
다음과 같은 관계를 가지는 ERD를 설계할 수 있어.

📌 ERD 개요

**회원(Member)**는 **도서를 대출(Rent)**할 수 있음.
**도서(Book)**는 여러 회원이 대출할 수 있음 (N:M 관계).
연체(Overdue) 및 **대출 기록(Log)**을 별도로 관리하여 기록을 유지.
관리자(Admin)와 일반 사용자(User)를 구분하는 로그인 시스템 구현.
📍 개념적 모델

scss
복사
편집
[MEMBER] 1 ─── N [RENT] N ─── 1 [BOOK]
   │                        │
   │                        └─── [OVERDUE] (연체 내역)
   └─── [ADMIN] (사서 계정)
📌 2. 테이블 정의서 (Schema Definition)
📂 2-1. 회원 테이블 (MEMBER)
컬럼명	타입	설명
ID	INT (PK)	회원 ID (자동 증가)
USERNAME	VARCHAR(50)	로그인 ID
PASSWORD	VARCHAR(255)	비밀번호 (해싱 적용)
NAME	VARCHAR(100)	회원 이름
ROLE	ENUM('USER', 'ADMIN')	역할 (일반 사용자/사서)
GENDER	ENUM('M','F')	성별
MOBILE	VARCHAR(20)	휴대폰 번호
EMAIL	VARCHAR(100)	이메일 주소
REGISTERED	TIMESTAMP	가입일
UPDATED	TIMESTAMP	수정일
📂 2-2. 도서 테이블 (BOOK)
컬럼명	타입	설명
ID	INT (PK)	도서 ID (자동 증가)
TITLE	VARCHAR(255)	도서 제목
ISBN	VARCHAR(20)	ISBN 번호
AUTHOR	VARCHAR(100)	저자
PUBLISHER	VARCHAR(100)	출판사
ISSUE_YEAR	INT	출판 연도
PRICE	DECIMAL(10,2)	도서 가격
STOCK	INT	보유 권수
CREATED	TIMESTAMP	생성일
UPDATED	TIMESTAMP	수정일
📂 2-3. 대출 테이블 (RENT)
컬럼명	타입	설명
ID	INT (PK)	대출 ID (자동 증가)
BOOK_ID	INT (FK)	도서 ID (BOOK 참조)
MEMBER_ID	INT (FK)	회원 ID (MEMBER 참조)
RENT_DATE	TIMESTAMP	대출일
EXPECTED_RETURN	TIMESTAMP	반납 예정일 (대출일 + 14일)
RETURNED_DATE	TIMESTAMP	실제 반납일 (NULL: 미반납)
EXTENDED_DATE	TIMESTAMP	연장된 날짜 (NULL이면 연장 안 함)
STATUS	ENUM('대출중', '반납됨', '연체')	대출 상태
📌 제약 조건

한 회원이 최대 5권까지 대출 가능하도록 제약 설정 필요.
📂 2-4. 연체 테이블 (OVERDUE)
컬럼명	타입	설명
ID	INT (PK)	연체 ID (자동 증가)
RENT_ID	INT (FK)	대출 ID (RENT 참조)
MEMBER_ID	INT (FK)	회원 ID (MEMBER 참조)
OVERDUE_DAYS	INT	연체 일수
FINE_AMOUNT	DECIMAL(10,2)	연체료 (1일당 500원)
PAID_STATUS	ENUM('미납', '완납')	연체료 납부 상태
📌 연체료 계산

FINE_AMOUNT = OVERDUE_DAYS * 500
반납 시 연체 내역 자동 업데이트.
📂 2-5. 대출/반납 로그 테이블 (RENT_LOG)
컬럼명	타입	설명
ID	INT (PK)	로그 ID (자동 증가)
RENT_ID	INT (FK)	대출 ID (RENT 참조)
MEMBER_ID	INT (FK)	회원 ID (MEMBER 참조)
BOOK_ID	INT (FK)	도서 ID (BOOK 참조)
ACTION	ENUM('대출', '반납', '연장')	수행된 작업
TIMESTAMP	TIMESTAMP	수행된 시간
📌 3. 요구사항 명세서
✅ 필수 요구사항
📍 로그인 시스템
 회원 가입 (비밀번호 해싱 적용)
 로그인 (ID/PW 입력 후 인증)
 관리자(Admin) / 일반 사용자(User) 권한 구분
관리자: 모든 도서 및 회원 정보 관리 가능
사용자: 본인 정보만 수정 가능
📍 도서 관리
 도서 등록 (C)
 도서 검색 (R) - 제목, 저자 검색
 도서 정보 수정 (U)
 도서 삭제 (D)
📍 회원 관리
 회원 가입 (C)
 회원 검색 (R) - 관리자만 전체 목록 조회 가능
 회원 정보 수정 (U) - 본인 정보만 수정 가능
 회원 탈퇴 (D)
📍 대출 관리
 대출 (C) - 한 회원당 최대 5권 제한
 반납 (U)
 대출 연장 (U)
 대출 내역 조회 (R)
현재 대출 중인 책 조회
반납 완료 내역 조회
연체 내역 조회
📍 연체 관리
 연체 발생 시 자동 기록
 연체료 부과 (500원/일)
 연체료 납부 상태 업데이트
📍 대출/반납 로그 관리
 대출, 반납, 연장 내역 기록
 로그 조회 기능 제공
📌 4. 개발 계획
단계	세부 내용	설명
1단계	환경 설정	Java + Eclipse + MySQL
2단계	ERD 설계	MySQL 테이블 정의
3단계	로그인 시스템	회원 가입, 로그인 기능 구현
4단계	CRUD 구현	도서 및 회원 관리 기능
5단계	대출/반납 기능	대출, 반납, 연체 처리 기능
6단계	로그 기록	대출 및 반납 로그 시스템 구현
7단계	테스트	데이터 입력 및 검증
8단계	문서화	README.md 작성 및 GitHub 등록
이제 다음 단계로 **SQL 테이블 생성 스크립트와 Java 개발 구조 (DAO, Service, Controller 설계)**를 만들어줄게. 준비되었으면 말해줘! 🚀







나의 말:
준비됐어
ChatGPT의 말:
좋아! 이제 SQL 테이블 생성 스크립트와 **Java 개발 구조 (DAO, Service, Controller 설계)**를 진행할게.

📌 1. MySQL 테이블 생성 스크립트
다음은 MySQL에서 사용할 테이블 생성 SQL 스크립트야.

📂 1-1. 회원 테이블 (MEMBER)
sql
복사
편집
CREATE TABLE MEMBER (
    ID INT AUTO_INCREMENT PRIMARY KEY,
    USERNAME VARCHAR(50) NOT NULL UNIQUE,
    PASSWORD VARCHAR(255) NOT NULL,
    NAME VARCHAR(100) NOT NULL,
    ROLE ENUM('USER', 'ADMIN') NOT NULL DEFAULT 'USER',
    GENDER ENUM('M','F'),
    MOBILE VARCHAR(20) UNIQUE,
    EMAIL VARCHAR(100) UNIQUE,
    REGISTERED TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
📌 설명:

USERNAME을 기준으로 로그인 ID를 관리.
PASSWORD는 해싱 적용 필요.
ROLE을 사용해 관리자(ADMIN)와 일반 회원(USER) 구분.
📂 1-2. 도서 테이블 (BOOK)
sql
복사
편집
CREATE TABLE BOOK (
    ID INT AUTO_INCREMENT PRIMARY KEY,
    TITLE VARCHAR(255) NOT NULL,
    ISBN VARCHAR(20) NOT NULL UNIQUE,
    AUTHOR VARCHAR(100) NOT NULL,
    PUBLISHER VARCHAR(100),
    ISSUE_YEAR INT,
    PRICE DECIMAL(10,2),
    STOCK INT NOT NULL DEFAULT 1,
    CREATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
📌 설명:

ISBN을 기준으로 중복 등록 방지.
STOCK을 통해 도서의 총 보유 권수 관리.
📂 1-3. 대출 테이블 (RENT)
sql
복사
편집
CREATE TABLE RENT (
    ID INT AUTO_INCREMENT PRIMARY KEY,
    BOOK_ID INT NOT NULL,
    MEMBER_ID INT NOT NULL,
    RENT_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    EXPECTED_RETURN TIMESTAMP GENERATED ALWAYS AS (RENT_DATE + INTERVAL 14 DAY) STORED,
    RETURNED_DATE TIMESTAMP NULL,
    EXTENDED_DATE TIMESTAMP NULL,
    STATUS ENUM('대출중', '반납됨', '연체') NOT NULL DEFAULT '대출중',
    FOREIGN KEY (BOOK_ID) REFERENCES BOOK(ID) ON DELETE CASCADE,
    FOREIGN KEY (MEMBER_ID) REFERENCES MEMBER(ID) ON DELETE CASCADE
);
📌 설명:

EXPECTED_RETURN은 자동으로 14일 뒤 계산.
STATUS는 대출중, 반납됨, 연체 세 가지 상태.
반납 시 RETURNED_DATE가 기록됨.
📂 1-4. 연체 테이블 (OVERDUE)
sql
복사
편집
CREATE TABLE OVERDUE (
    ID INT AUTO_INCREMENT PRIMARY KEY,
    RENT_ID INT NOT NULL,
    MEMBER_ID INT NOT NULL,
    OVERDUE_DAYS INT GENERATED ALWAYS AS (DATEDIFF(CURRENT_DATE, EXPECTED_RETURN)) STORED,
    FINE_AMOUNT DECIMAL(10,2) GENERATED ALWAYS AS (OVERDUE_DAYS * 500) STORED,
    PAID_STATUS ENUM('미납', '완납') NOT NULL DEFAULT '미납',
    FOREIGN KEY (RENT_ID) REFERENCES RENT(ID) ON DELETE CASCADE,
    FOREIGN KEY (MEMBER_ID) REFERENCES MEMBER(ID) ON DELETE CASCADE
);
📌 설명:

OVERDUE_DAYS는 EXPECTED_RETURN과 현재 날짜 차이 계산.
FINE_AMOUNT는 하루 500원씩 자동 계산.
PAID_STATUS는 연체료 납부 여부.
📂 1-5. 대출/반납 로그 테이블 (RENT_LOG)
sql
복사
편집
CREATE TABLE RENT_LOG (
    ID INT AUTO_INCREMENT PRIMARY KEY,
    RENT_ID INT NOT NULL,
    MEMBER_ID INT NOT NULL,
    BOOK_ID INT NOT NULL,
    ACTION ENUM('대출', '반납', '연장') NOT NULL,
    TIMESTAMP TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (RENT_ID) REFERENCES RENT(ID) ON DELETE CASCADE,
    FOREIGN KEY (MEMBER_ID) REFERENCES MEMBER(ID) ON DELETE CASCADE,
    FOREIGN KEY (BOOK_ID) REFERENCES BOOK(ID) ON DELETE CASCADE
);
📌 설명:

ACTION을 통해 대출/반납/연장 기록 관리.
📌 2. Java 개발 구조 설계
🔹 기본적인 MVC 패턴 적용
scss
복사
편집
📂 src
 ├── 📂 dao       (DB 연결 및 CRUD 담당)
 ├── 📂 service   (비즈니스 로직 담당)
 ├── 📂 controller (사용자 입력 처리)
 ├── 📂 model     (VO/DTO 객체)
 ├── 📂 util      (DB 연결, 암호화)
 ├── Main.java    (메인 실행 파일)
📌 3. Java DAO 클래스 설계
📂 MemberDAO.java (회원 관리)
java
복사
편집
package dao;
import model.Member;
import util.DBConnection;
import java.sql.*;

public class MemberDAO {
    public boolean registerMember(Member member) {
        String query = "INSERT INTO MEMBER (USERNAME, PASSWORD, NAME, ROLE, GENDER, MOBILE, EMAIL) VALUES (?, ?, ?, ?, ?, ?, ?)";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setString(1, member.getUsername());
            pstmt.setString(2, member.getPassword()); // 비밀번호 해싱 필요
            pstmt.setString(3, member.getName());
            pstmt.setString(4, member.getRole());
            pstmt.setString(5, member.getGender());
            pstmt.setString(6, member.getMobile());
            pstmt.setString(7, member.getEmail());
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }
    
    public Member login(String username, String password) {
        String query = "SELECT * FROM MEMBER WHERE USERNAME = ? AND PASSWORD = ?";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setString(1, username);
            pstmt.setString(2, password); // 해싱된 비밀번호 비교 필요
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return new Member(rs.getInt("ID"), rs.getString("USERNAME"), rs.getString("ROLE"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }
}
📌 설명:

registerMember(): 회원가입 기능 구현.
login(): 로그인 시 ID/PW 검증 후 ROLE 반환.
📌 4. 개발 진행 계획
단계	작업 내용
1단계	MySQL 테이블 생성 및 ERD 확정
2단계	Java 프로젝트 구조 세팅
3단계	DB 연결 클래스 및 DAO 구현
4단계	회원가입 및 로그인 기능 개발
5단계	도서 등록 및 검색 기능 구현
6단계	대출/반납 기능 구현
7단계	연체료 계산 및 로그 기록 추가
8단계	콘솔 UI 개선 및 테스트
이제 DB 연결 클래스 (DBConnection.java) 및 도서 관리 DAO(BookDAO.java) 코드를 추가로 작성해볼까? 🚀







나의 말:
응 작성해줘
ChatGPT의 말:
좋아! 이제 DB 연결 클래스 (DBConnection.java) 및 도서 관리 DAO (BookDAO.java) 코드를 작성할게.

📌 1. DB 연결 클래스 (DBConnection.java)
데이터베이스와 연결을 관리하는 유틸리티 클래스를 만들어줄게.

📂 util/DBConnection.java
java
복사
편집
package util;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DBConnection {
    private static final String URL = "jdbc:mysql://localhost:3306/library_db"; // 데이터베이스 이름 확인
    private static final String USER = "root"; // MySQL 사용자 이름
    private static final String PASSWORD = "yourpassword"; // MySQL 비밀번호

    // 데이터베이스 연결 메서드
    public static Connection getConnection() {
        Connection conn = null;
        try {
            Class.forName("com.mysql.cj.jdbc.Driver"); // MySQL 드라이버 로드
            conn = DriverManager.getConnection(URL, USER, PASSWORD);
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }

    // 연결 해제 메서드
    public static void closeConnection(Connection conn) {
        try {
            if (conn != null && !conn.isClosed()) {
                conn.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
📌 설명:

MySQL과 연결하는 getConnection() 메서드 포함.
closeConnection()으로 연결을 닫아 리소스 관리.
📌 2. 도서 관리 DAO (BookDAO.java)
도서 정보를 관리하는 DAO 클래스를 작성할게.

📂 dao/BookDAO.java
java
복사
편집
package dao;
import model.Book;
import util.DBConnection;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class BookDAO {

    // 도서 등록 (Create)
    public boolean addBook(Book book) {
        String query = "INSERT INTO BOOK (TITLE, ISBN, AUTHOR, PUBLISHER, ISSUE_YEAR, PRICE, STOCK) VALUES (?, ?, ?, ?, ?, ?, ?)";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setString(1, book.getTitle());
            pstmt.setString(2, book.getIsbn());
            pstmt.setString(3, book.getAuthor());
            pstmt.setString(4, book.getPublisher());
            pstmt.setInt(5, book.getIssueYear());
            pstmt.setDouble(6, book.getPrice());
            pstmt.setInt(7, book.getStock());
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }

    // 도서 목록 조회 (Read)
    public List<Book> getAllBooks() {
        List<Book> books = new ArrayList<>();
        String query = "SELECT * FROM BOOK";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query);
             ResultSet rs = pstmt.executeQuery()) {
            while (rs.next()) {
                books.add(new Book(
                        rs.getInt("ID"),
                        rs.getString("TITLE"),
                        rs.getString("ISBN"),
                        rs.getString("AUTHOR"),
                        rs.getString("PUBLISHER"),
                        rs.getInt("ISSUE_YEAR"),
                        rs.getDouble("PRICE"),
                        rs.getInt("STOCK")
                ));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return books;
    }

    // 특정 도서 검색 (제목 또는 저자로 검색)
    public List<Book> searchBooks(String keyword) {
        List<Book> books = new ArrayList<>();
        String query = "SELECT * FROM BOOK WHERE TITLE LIKE ? OR AUTHOR LIKE ?";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setString(1, "%" + keyword + "%");
            pstmt.setString(2, "%" + keyword + "%");
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                books.add(new Book(
                        rs.getInt("ID"),
                        rs.getString("TITLE"),
                        rs.getString("ISBN"),
                        rs.getString("AUTHOR"),
                        rs.getString("PUBLISHER"),
                        rs.getInt("ISSUE_YEAR"),
                        rs.getDouble("PRICE"),
                        rs.getInt("STOCK")
                ));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return books;
    }

    // 도서 정보 수정 (Update)
    public boolean updateBook(Book book) {
        String query = "UPDATE BOOK SET TITLE=?, AUTHOR=?, PUBLISHER=?, ISSUE_YEAR=?, PRICE=?, STOCK=? WHERE ISBN=?";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setString(1, book.getTitle());
            pstmt.setString(2, book.getAuthor());
            pstmt.setString(3, book.getPublisher());
            pstmt.setInt(4, book.getIssueYear());
            pstmt.setDouble(5, book.getPrice());
            pstmt.setInt(6, book.getStock());
            pstmt.setString(7, book.getIsbn());
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }

    // 도서 삭제 (Delete)
    public boolean deleteBook(String isbn) {
        String query = "DELETE FROM BOOK WHERE ISBN=?";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setString(1, isbn);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }
}
📌 설명:

addBook(): 도서 추가
getAllBooks(): 모든 도서 조회
searchBooks(): 제목 또는 저자로 검색
updateBook(): 도서 정보 수정
deleteBook(): 도서 삭제
📌 3. 도서 객체 모델 (Book.java)
📂 model/Book.java
java
복사
편집
package model;

public class Book {
    private int id;
    private String title;
    private String isbn;
    private String author;
    private String publisher;
    private int issueYear;
    private double price;
    private int stock;

    public Book(int id, String title, String isbn, String author, String publisher, int issueYear, double price, int stock) {
        this.id = id;
        this.title = title;
        this.isbn = isbn;
        this.author = author;
        this.publisher = publisher;
        this.issueYear = issueYear;
        this.price = price;
        this.stock = stock;
    }

    // Getters and Setters
    public int getId() { return id; }
    public String getTitle() { return title; }
    public String getIsbn() { return isbn; }
    public String getAuthor() { return author; }
    public String getPublisher() { return publisher; }
    public int getIssueYear() { return issueYear; }
    public double getPrice() { return price; }
    public int getStock() { return stock; }

    public void setId(int id) { this.id = id; }
    public void setTitle(String title) { this.title = title; }
    public void setIsbn(String isbn) { this.isbn = isbn; }
    public void setAuthor(String author) { this.author = author; }
    public void setPublisher(String publisher) { this.publisher = publisher; }
    public void setIssueYear(int issueYear) { this.issueYear = issueYear; }
    public void setPrice(double price) { this.price = price; }
    public void setStock(int stock) { this.stock = stock; }
}
📌 설명:

Book 객체를 관리하는 모델 클래스.
이제 대출 관리 DAO (RentDAO.java) 및 서비스 클래스를 만들어줄까? 🚀







나의 말:
응
ChatGPT의 말:
좋아! 이제 대출 관리 DAO (RentDAO.java) 및 **대출 서비스 클래스 (RentService.java)**를 작성할게.

📌 1. 대출 관리 DAO (RentDAO.java)
📂 dao/RentDAO.java
java
복사
편집
package dao;
import model.Rent;
import util.DBConnection;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class RentDAO {

    // 도서 대출 (Create)
    public boolean rentBook(int bookId, int memberId) {
        String checkQuery = "SELECT COUNT(*) FROM RENT WHERE MEMBER_ID = ? AND STATUS = '대출중'";
        String insertQuery = "INSERT INTO RENT (BOOK_ID, MEMBER_ID, RENT_DATE, STATUS) VALUES (?, ?, CURRENT_TIMESTAMP, '대출중')";
        String updateStockQuery = "UPDATE BOOK SET STOCK = STOCK - 1 WHERE ID = ? AND STOCK > 0";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement checkStmt = conn.prepareStatement(checkQuery);
             PreparedStatement insertStmt = conn.prepareStatement(insertQuery);
             PreparedStatement updateStockStmt = conn.prepareStatement(updateStockQuery)) {

            // 회원이 대출 중인 책 개수 확인 (최대 5권)
            checkStmt.setInt(1, memberId);
            ResultSet rs = checkStmt.executeQuery();
            if (rs.next() && rs.getInt(1) >= 5) {
                System.out.println("대출 가능한 최대 권수를 초과하였습니다.");
                return false;
            }

            // 도서 대출 처리
            insertStmt.setInt(1, bookId);
            insertStmt.setInt(2, memberId);
            if (insertStmt.executeUpdate() > 0) {
                // 도서 보유 수량 감소
                updateStockStmt.setInt(1, bookId);
                updateStockStmt.executeUpdate();
                return true;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    // 대출 내역 조회 (Read)
    public List<Rent> getRentHistory(int memberId) {
        List<Rent> rentList = new ArrayList<>();
        String query = "SELECT * FROM RENT WHERE MEMBER_ID = ?";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setInt(1, memberId);
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                rentList.add(new Rent(
                        rs.getInt("ID"),
                        rs.getInt("BOOK_ID"),
                        rs.getInt("MEMBER_ID"),
                        rs.getTimestamp("RENT_DATE"),
                        rs.getTimestamp("EXPECTED_RETURN"),
                        rs.getTimestamp("RETURNED_DATE"),
                        rs.getTimestamp("EXTENDED_DATE"),
                        rs.getString("STATUS")
                ));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return rentList;
    }

    // 도서 반납 (Update)
    public boolean returnBook(int rentId) {
        String updateRentQuery = "UPDATE RENT SET RETURNED_DATE = CURRENT_TIMESTAMP, STATUS = '반납됨' WHERE ID = ?";
        String updateStockQuery = "UPDATE BOOK SET STOCK = STOCK + 1 WHERE ID = (SELECT BOOK_ID FROM RENT WHERE ID = ?)";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement updateRentStmt = conn.prepareStatement(updateRentQuery);
             PreparedStatement updateStockStmt = conn.prepareStatement(updateStockQuery)) {

            updateRentStmt.setInt(1, rentId);
            if (updateRentStmt.executeUpdate() > 0) {
                updateStockStmt.setInt(1, rentId);
                updateStockStmt.executeUpdate();
                return true;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    // 대출 연장 (Update)
    public boolean extendRent(int rentId) {
        String updateQuery = "UPDATE RENT SET EXTENDED_DATE = CURRENT_TIMESTAMP, EXPECTED_RETURN = EXPECTED_RETURN + INTERVAL 14 DAY WHERE ID = ? AND EXTENDED_DATE IS NULL";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(updateQuery)) {
            pstmt.setInt(1, rentId);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    // 연체 여부 확인 (Read)
    public boolean checkOverdue(int rentId) {
        String query = "SELECT EXPECTED_RETURN FROM RENT WHERE ID = ? AND STATUS = '대출중'";

        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setInt(1, rentId);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                Timestamp expectedReturn = rs.getTimestamp("EXPECTED_RETURN");
                return expectedReturn.before(new Timestamp(System.currentTimeMillis()));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }
}
📌 설명:

rentBook(): 대출 기능 (최대 5권까지 제한).
getRentHistory(): 특정 회원의 대출 내역 조회.
returnBook(): 반납 시 RETURNED_DATE 설정 및 STOCK 증가.
extendRent(): 연장 기능 (EXPECTED_RETURN + 14일).
checkOverdue(): 연체 여부 확인.
📌 2. 대출 서비스 클래스 (RentService.java)
📂 service/RentService.java
java
복사
편집
package service;
import dao.RentDAO;
import java.util.Scanner;

public class RentService {
    private RentDAO rentDAO = new RentDAO();
    private Scanner scanner = new Scanner(System.in);

    // 도서 대출 기능
    public void rentBook(int memberId) {
        System.out.print("대출할 도서 ID를 입력하세요: ");
        int bookId = scanner.nextInt();

        if (rentDAO.rentBook(bookId, memberId)) {
            System.out.println("도서가 성공적으로 대출되었습니다.");
        } else {
            System.out.println("대출에 실패하였습니다.");
        }
    }

    // 대출 내역 조회
    public void viewRentHistory(int memberId) {
        rentDAO.getRentHistory(memberId).forEach(rent -> {
            System.out.println("대출 ID: " + rent.getId() +
                    ", 도서 ID: " + rent.getBookId() +
                    ", 대출일: " + rent.getRentDate() +
                    ", 반납 예정일: " + rent.getExpectedReturn() +
                    ", 상태: " + rent.getStatus());
        });
    }

    // 반납 기능
    public void returnBook() {
        System.out.print("반납할 대출 ID를 입력하세요: ");
        int rentId = scanner.nextInt();

        if (rentDAO.returnBook(rentId)) {
            System.out.println("도서가 성공적으로 반납되었습니다.");
        } else {
            System.out.println("반납에 실패하였습니다.");
        }
    }

    // 대출 연장 기능
    public void extendRent() {
        System.out.print("연장할 대출 ID를 입력하세요: ");
        int rentId = scanner.nextInt();

        if (rentDAO.extendRent(rentId)) {
            System.out.println("대출이 연장되었습니다.");
        } else {
            System.out.println("연장에 실패하였습니다.");
        }
    }
}
📌 설명:

rentBook(): 사용자 입력을 받아 대출 진행.
viewRentHistory(): 대출 내역 조회.
returnBook(): 반납 기능 수행.
extendRent(): 연장 기능 수행.
📌 3. 다음 단계
✅ 완료한 부분

DB 테이블 생성 SQL
DB 연결 클래스
도서 관리 DAO
대출 관리 DAO
대출 서비스 클래스
🚀 다음으로 할 일

회원 관리 DAO (MemberDAO.java)
회원 서비스 클래스 (MemberService.java)
메인 실행 파일 (Main.java)
로그인 및 권한 분리 적용
이제 회원 관리 기능 (가입, 로그인, 권한 관리) 및 Main.java를 구현할까? 😊







나의 말:
응
ChatGPT의 말:
좋아! 이제 회원 관리 DAO (MemberDAO.java), 회원 서비스 클래스 (MemberService.java), 그리고 **메인 실행 파일 (Main.java)**을 구현할게.

📌 1. 회원 관리 DAO (MemberDAO.java)
📂 dao/MemberDAO.java
java
복사
편집
package dao;
import model.Member;
import util.DBConnection;
import java.sql.*;

public class MemberDAO {

    // 회원 가입 (Create)
    public boolean registerMember(Member member) {
        String query = "INSERT INTO MEMBER (USERNAME, PASSWORD, NAME, ROLE, GENDER, MOBILE, EMAIL) VALUES (?, ?, ?, ?, ?, ?, ?)";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setString(1, member.getUsername());
            pstmt.setString(2, member.getPassword()); // 비밀번호는 해싱 후 저장 필요
            pstmt.setString(3, member.getName());
            pstmt.setString(4, member.getRole());
            pstmt.setString(5, member.getGender());
            pstmt.setString(6, member.getMobile());
            pstmt.setString(7, member.getEmail());
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }

    // 로그인 기능 (Read)
    public Member login(String username, String password) {
        String query = "SELECT * FROM MEMBER WHERE USERNAME = ? AND PASSWORD = ?";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query)) {
            pstmt.setString(1, username);
            pstmt.setString(2, password); // 실제 구현에서는 해싱된 비밀번호 비교 필요
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return new Member(
                        rs.getInt("ID"),
                        rs.getString("USERNAME"),
                        rs.getString("NAME"),
                        rs.getString("ROLE"),
                        rs.getString("EMAIL")
                );
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    // 회원 정보 조회 (관리자용)
    public void viewAllMembers() {
        String query = "SELECT ID, USERNAME, NAME, ROLE, EMAIL FROM MEMBER";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query);
             ResultSet rs = pstmt.executeQuery()) {
            while (rs.next()) {
                System.out.println("ID: " + rs.getInt("ID") +
                        ", USERNAME: " + rs.getString("USERNAME") +
                        ", NAME: " + rs.getString("NAME") +
                        ", ROLE: " + rs.getString("ROLE") +
                        ", EMAIL: " + rs.getString("EMAIL"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
📌 설명:

registerMember(): 회원 가입 처리.
login(): 로그인 후 Member 객체 반환.
viewAllMembers(): 관리자(admin)용 전체 회원 조회.
📌 2. 회원 서비스 클래스 (MemberService.java)
📂 service/MemberService.java
java
복사
편집
package service;
import dao.MemberDAO;
import model.Member;
import java.util.Scanner;

public class MemberService {
    private MemberDAO memberDAO = new MemberDAO();
    private Scanner scanner = new Scanner(System.in);

    // 회원 가입
    public void register() {
        System.out.print("사용할 사용자명을 입력하세요: ");
        String username = scanner.next();
        System.out.print("비밀번호를 입력하세요: ");
        String password = scanner.next();  // 실제 구현에서는 비밀번호 해싱 필요
        System.out.print("이름을 입력하세요: ");
        String name = scanner.next();
        System.out.print("역할을 입력하세요 (USER/ADMIN): ");
        String role = scanner.next().toUpperCase();
        System.out.print("성별을 입력하세요 (M/F): ");
        String gender = scanner.next();
        System.out.print("휴대폰 번호를 입력하세요: ");
        String mobile = scanner.next();
        System.out.print("이메일을 입력하세요: ");
        String email = scanner.next();

        Member member = new Member(0, username, password, name, role, gender, mobile, email);
        if (memberDAO.registerMember(member)) {
            System.out.println("회원 가입이 완료되었습니다.");
        } else {
            System.out.println("회원 가입에 실패하였습니다.");
        }
    }

    // 로그인
    public Member login() {
        System.out.print("사용자명을 입력하세요: ");
        String username = scanner.next();
        System.out.print("비밀번호를 입력하세요: ");
        String password = scanner.next();

        Member member = memberDAO.login(username, password);
        if (member != null) {
            System.out.println("로그인 성공! " + member.getName() + "님 환영합니다.");
        } else {
            System.out.println("로그인 실패! 사용자명 또는 비밀번호를 확인하세요.");
        }
        return member;
    }
}
📌 설명:

register(): 사용자 입력을 받아 회원 가입 진행.
login(): 로그인 성공 시 Member 객체 반환.
📌 3. 메인 실행 파일 (Main.java)
📂 Main.java
java
복사
편집
import service.MemberService;
import service.RentService;
import java.util.Scanner;
import model.Member;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        MemberService memberService = new MemberService();
        RentService rentService = new RentService();
        Member currentUser = null;

        while (true) {
            System.out.println("\n=== 도서 대여 관리 시스템 ===");
            System.out.println("1. 회원 가입");
            System.out.println("2. 로그인");
            System.out.println("3. 종료");
            System.out.print("메뉴 선택: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    memberService.register();
                    break;
                case 2:
                    currentUser = memberService.login();
                    if (currentUser != null) {
                        handleUserMenu(currentUser, rentService);
                    }
                    break;
                case 3:
                    System.out.println("프로그램을 종료합니다.");
                    scanner.close();
                    System.exit(0);
                default:
                    System.out.println("올바른 번호를 입력하세요.");
            }
        }
    }

    private static void handleUserMenu(Member user, RentService rentService) {
        Scanner scanner = new Scanner(System.in);
        boolean isAdmin = user.getRole().equals("ADMIN");

        while (true) {
            System.out.println("\n=== 사용자 메뉴 (" + user.getRole() + ") ===");
            System.out.println("1. 도서 대출");
            System.out.println("2. 대출 내역 조회");
            System.out.println("3. 도서 반납");
            System.out.println("4. 대출 연장");
            if (isAdmin) {
                System.out.println("5. 전체 회원 조회");
            }
            System.out.println("6. 로그아웃");
            System.out.print("메뉴 선택: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    rentService.rentBook(user.getId());
                    break;
                case 2:
                    rentService.viewRentHistory(user.getId());
                    break;
                case 3:
                    rentService.returnBook();
                    break;
                case 4:
                    rentService.extendRent();
                    break;
                case 5:
                    if (isAdmin) {
                        new dao.MemberDAO().viewAllMembers();
                    } else {
                        System.out.println("잘못된 선택입니다.");
                    }
                    break;
                case 6:
                    System.out.println("로그아웃합니다.");
                    return;
                default:
                    System.out.println("올바른 번호를 입력하세요.");
            }
        }
    }
}
📌 설명:

메인 메뉴: 회원가입, 로그인, 종료
로그인 성공 시: 사용자 메뉴 실행
사용자 메뉴: 도서 대출, 반납, 연장 가능
관리자(admin) 메뉴: 전체 회원 조회 가능
📌 4. 마무리
✅ 완료한 부분

회원 관리 (가입, 로그인, 회원 조회)
도서 관리
대출 관리
연체 관리
메인 실행 파일 완성
🚀 이제 실행해서 테스트해보자!
테스트하면서 버그나 개선할 점이 있으면 말해줘! 😊







나의 말:
DAO가 뭐의 줄임말이야
ChatGPT의 말:
DAO는 Data Access Object의 줄임말이야.

📌 DAO (Data Access Object)란?
데이터베이스와의 상호작용을 담당하는 객체를 의미해.
SQL을 직접 호출하는 대신, DAO 클래스를 만들어 데이터베이스 작업을 캡슐화하고 코드의 재사용성과 유지보수성을 높이는 역할을 해.
보통 insert, select, update, delete 같은 CRUD(Create, Read, Update, Delete) 기능을 수행해.
📌 DAO를 사용하는 이유
코드 분리 및 유지보수 용이
비즈니스 로직(Service)과 데이터 접근 로직(DB)을 분리하여 유지보수를 쉽게 만듦.
재사용성 증가
DAO를 여러 서비스에서 호출할 수 있어 중복 코드가 줄어듦.
DB 변경 시 유연한 대응 가능
DB 구조가 변경되더라도 DAO만 수정하면 되므로, 전체 코드를 변경할 필요가 없음.
📌 DAO 패턴 구조
DAO 패턴은 보통 다음과 같은 구조로 이루어져:

scss
복사
편집
📂 src
 ├── 📂 dao        (데이터베이스 접근, SQL 실행)
 │    ├── MemberDAO.java
 │    ├── BookDAO.java
 │    ├── RentDAO.java
 ├── 📂 service    (비즈니스 로직, DAO 호출)
 │    ├── MemberService.java
 │    ├── RentService.java
 ├── 📂 model      (데이터 객체, DTO)
 │    ├── Member.java
 │    ├── Book.java
 │    ├── Rent.java
 ├── 📂 util       (DB 연결 및 기타 기능)
 │    ├── DBConnection.java
 ├── Main.java     (프로그램 실행)
📌 DAO 예시 코드
java
복사
편집
public class BookDAO {
    public List<Book> getAllBooks() {
        List<Book> books = new ArrayList<>();
        String query = "SELECT * FROM BOOK";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query);
             ResultSet rs = pstmt.executeQuery()) {
            while (rs.next()) {
                books.add(new Book(
                        rs.getInt("ID"),
                        rs.getString("TITLE"),
                        rs.getString("AUTHOR")
                ));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return books;
    }
}
📌 설명:

getAllBooks()는 BOOK 테이블에서 모든 도서를 조회하는 DAO 메서드.
Connection을 열어 SQL을 실행하고, 결과를 Book 객체 리스트로 반환.
📌 정리
DAO (Data Access Object)는 DB와 직접 연결하여 데이터를 CRUD하는 역할을 하는 객체.
비즈니스 로직(Service)과 DB 접근 코드를 분리하여 유지보수를 쉽게 함.
SQL을 직접 호출하는 대신 DAO를 통해 데이터베이스와 상호작용함.
쉽게 말하면, DAO는 "DB와 연결하여 데이터를 가져오고 저장하는 역할"을 하는 클래스야! 😊







나의 말:
MODEL 패키지 그러니까 DTO는 왜 필요한거야
ChatGPT의 말:
📌 DTO (Data Transfer Object)란?
DTO는 Data Transfer Object의 줄임말이야.
즉, 데이터를 한 곳에서 다른 곳으로 전달할 때 사용하는 객체야.

📌 DTO가 필요한 이유
데이터 캡슐화 (Encapsulation)

데이터를 객체 형태로 관리해서 SQL 실행 결과를 직접 다루지 않고, 객체 단위로 처리할 수 있음.
데이터 전달의 효율성

여러 필드를 묶어서 한 번에 전달할 수 있어 코드를 간결하게 유지할 수 있음.
유지보수성과 가독성 향상

데이터베이스 테이블의 컬럼을 직접 다루지 않고 객체 기반으로 데이터를 관리하면 유지보수가 쉬워짐.
데이터를 DTO 클래스로 한 번에 관리하면 가독성이 향상됨.
📌 DAO vs DTO 차이점
구분	DAO (Data Access Object)	DTO (Data Transfer Object)
역할	DB에 접근하여 데이터를 가져오거나 수정하는 역할	데이터를 저장하고 전달하는 역할
SQL 사용 여부	SQL을 사용하여 DB와 직접 연동	SQL 사용 X, 단순한 객체
책임	DB CRUD 연산을 담당	데이터 보관 및 전달
예제	BookDAO, MemberDAO	Book, Member
📌 DTO 사용 예시
📂 model/Book.java (DTO 예제)
java
복사
편집
package model;

public class Book {
    private int id;
    private String title;
    private String isbn;
    private String author;
    private String publisher;
    private int issueYear;
    private double price;
    private int stock;

    // 생성자
    public Book(int id, String title, String isbn, String author, String publisher, int issueYear, double price, int stock) {
        this.id = id;
        this.title = title;
        this.isbn = isbn;
        this.author = author;
        this.publisher = publisher;
        this.issueYear = issueYear;
        this.price = price;
        this.stock = stock;
    }

    // Getter & Setter 메서드
    public int getId() { return id; }
    public String getTitle() { return title; }
    public String getIsbn() { return isbn; }
    public String getAuthor() { return author; }
    public String getPublisher() { return publisher; }
    public int getIssueYear() { return issueYear; }
    public double getPrice() { return price; }
    public int getStock() { return stock; }

    public void setId(int id) { this.id = id; }
    public void setTitle(String title) { this.title = title; }
    public void setIsbn(String isbn) { this.isbn = isbn; }
    public void setAuthor(String author) { this.author = author; }
    public void setPublisher(String publisher) { this.publisher = publisher; }
    public void setIssueYear(int issueYear) { this.issueYear = issueYear; }
    public void setPrice(double price) { this.price = price; }
    public void setStock(int stock) { this.stock = stock; }
}
📌 설명:

Book 객체는 데이터베이스의 BOOK 테이블과 1:1 매칭되는 DTO 역할을 함.
DAO에서 조회한 데이터를 Book 객체에 저장하고, 필요한 곳에 전달할 수 있음.
📌 DAO에서 DTO를 사용하는 예시
📂 dao/BookDAO.java
java
복사
편집
package dao;
import model.Book;
import util.DBConnection;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class BookDAO {

    // 도서 목록 조회 (Read)
    public List<Book> getAllBooks() {
        List<Book> books = new ArrayList<>();
        String query = "SELECT * FROM BOOK";
        try (Connection conn = DBConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query);
             ResultSet rs = pstmt.executeQuery()) {
            while (rs.next()) {
                books.add(new Book(
                        rs.getInt("ID"),
                        rs.getString("TITLE"),
                        rs.getString("ISBN"),
                        rs.getString("AUTHOR"),
                        rs.getString("PUBLISHER"),
                        rs.getInt("ISSUE_YEAR"),
                        rs.getDouble("PRICE"),
                        rs.getInt("STOCK")
                ));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return books;
    }
}
📌 설명:

DAO는 데이터베이스에서 조회한 결과를 Book DTO 객체에 담아서 반환함.
이를 통해 서비스 계층(Service)에서 DTO 객체를 활용하여 데이터를 처리할 수 있음.
📌 DTO의 장점
✅ SQL을 직접 다루지 않고 객체 기반으로 데이터 관리
✅ 데이터의 이동과 전달을 쉽게 관리
✅ 코드 가독성이 향상되고 유지보수성이 좋아짐
✅ DAO와 비즈니스 로직을 분리하여 코드 구조를 깔끔하게 유지

📌 결론
👉 DTO는 데이터를 안전하고 체계적으로 전달하기 위한 객체야!
👉 DAO는 데이터베이스와 직접 연결하여 CRUD를 수행하고, DTO는 그 데이터를 담아서 전달하는 역할을 해.
👉 DAO → DTO → Service → Controller → View 이런 구조로 사용하면 코드가 훨씬 깔끔하고 유지보수가 쉬워져! 😊











검색


ChatGPT는 실수를 할 수 있습니다. 중요한 정보를 확인하세요.
